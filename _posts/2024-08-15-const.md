---
title: "[E-Z] const 리뷰하기🍨"
key: codereview
# category: tdd
tags: codereview
---
codereview
<!--more-->

# [E-Z] const 리뷰하기🍨
저는 종종 단순한 상수를 써야할 때 const, enum, inline 등 여러 구현 방법이 있는데도 매크로를 곧바로 편하게 쓸 때가 많습니다. 하지만 이 때의 매크로의 단점은 뚜렷하긴 하죠. 가장 먼저 생각나는 것은 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하면 헷갈린다는 점입니다.🙄  

## 디버깅이 쉬운 const
```cpp
#define PI 3.14
const double pi=3.14;
```

소스코드가 컴파일러에게 PI를 알려주기 전에, 선행 처리자가 숫자 상수로 대체해버리므로 컴파일러는 PI가 아니라 3.14로 인식합니다. 즉, PI는 컴파일러의 기호 테이블에 들어가지 않습니다. 이렇게 되면 매크로 사용 중 오류가 발생하면, 컴파일러의 에러 메시지가 매크로 치환에 대한 정보를 제공하지 않기 때문에 에러의 원인을 추적하기 어렵습니다.  
그래서 단순한 상수를 쓸 때는, `매크로` 대신 `const 객체`(또는 enum)를 쓰는 편이 좋습니다. `const 변수`는 실제 메모리 위치에 저장되기 때문에, 디버깅 도구를 사용하여 변수의 값을 직접 확인할 수 있습니다. 이는 에러를 추적하는데 유리합니다.   

단순한 상수를 정의하는데 매크로를 썼다면, 그 대신에 디버깅에 용이한 const 변수를 써보자는 코드리뷰를 할 수 있겠습니다.  

## 타입 에러를 체크할 수 있는 const

```c
const int MAX_SIZE = 100;
int array[MAX_SIZE];
```

const는 타입을 갖기 때문에, 변수의 타입과 값의 일관성을 보장합니다. 컴파일러는 타입과 관련된 오류를 체크할 수 있습니다.


```c
#define MAX_SIZE 100
int array[MAX_SIZE];
```

매크로 상수는 타입이 없기 때문에, 매크로 상수와 다른 타입의 값이 연산에 사용될 때 타입 관련 오류가 발생하지 않습니다.  


## 스코프 내에서 유효한 const
```c
const int MAX_SIZE = 100;

void function() {
    int array[MAX_SIZE];
    // `const` 변수 MAX_SIZE는 타입이 명확하고, 스코프가 제한됨
}
```


const 변수는 스코프 내에서만 유효하므로, 전역적으로 사용되는 매크로에 비해 이름 충돌의 가능성이 적습니다. 이 때, 상수가 필요한 스코프 내에서만 선언되었는지 검토해볼 수 있습니다.       

```c
#define MAX_SIZE 100

void function() {
    int array[MAX_SIZE];
    // 매크로 상수 MAX_SIZE가 변경되면, 모든 사용 코드에 영향을 미침
}
```

반대로 매크로는 전역적으로 유효하기 때문에, 이름 충돌이나 예상치 못한 동작을 초래할 수 있습니다. 전역적으로 유효하다는 특성을 이용해서 효율적으로 코드를 구성할 때도 있지만, 이름 충돌에 대한 리스크는 있습니다. 반드시 필요한 경우가 아니라면, 불필요한 전역선언을 피하고 const 변수를 쓸 수 있도록 리뷰할 수 있습니다.  


## 코드 가독성을 높이는 const
const는 개발자의 의도가 분명하게 녹아 있습니다. const 키워드가 붙은 객체는 외부 변경이 안되고, 이를 `의미적인 제약`이라고 합니다. 이러한 의미적인 제약을 소스 코드 수준에서 붙이고, 컴파일러가 제약을 지켜줍니다. 한 마디로, 어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러와 다른 프로그래머와 나눌 수 있는 수단입니다.  
`코드 가독성`측면에서 소개했지만, 이 의미적인 제약에는 `의도치 않은 버그 방지`, `높은 유지보수성`, `주석 없이 불변성 명시` 등을 전부 내포하고 있습니다.  

## const의 불변성 유의하기
첫째, 변수의 불변성을 확인하면서 const 변수를 리뷰할 수 있습니다.
```c
const x = 10;
x = 20; // 오류 발생
```

둘째, 상수로 선언된 변수들이 실제로 변경되지 않아야 하는 값들인지 검토합니다. 즉, 변수의 불변성이 논리적으로 맞는지 확인합니다.
```c
const MAX_USERS = 100; // 상수로 적절
const userName = 'John'; // 상수로 적절
```

계속해서 const의 장점 위주로 설명했지만, 값의 변경이 불가능하므로, 경우에 따라 유연성이 떨어질 수 있다는 단점이 될 수 있습니다. 값이 변경될 가능성이 있는 경우에는 const를 사용하기 적절하지 않을 수 있으므로 프로젝트의 
여러 상황을 고려하여 변수 불변성에 대한 논리성을 리뷰해볼 수 있습니다.

셋째, 객체나 배열을 const로 선언한 경우, 해당 객체나 배열의 요소는 변경할 수 있지만 변수 자체를 재할당할 수 없습니다. 이 점을 이해하고 적절히 사용되고 있는지 리뷰합니다.
```c
const arr = [1, 2, 3];
arr[2] = 4; // 가능
arr = [1, 2, 3, 4]; // 오류 발생
```

넷째, 함수 매개변수에 const를 붙일 수 있는데, 이를 통해 매개변수가 함수 내에서 변경되지 않음을 보장할 수 있습니다.

```c
void printMessage(const std::string& message) {
    std::cout << message << std::endl;
    // message는 const 참조로 전달되어서 함수 내에서 변경할 수 없음
}
```
여기서 const std::string&는 message가 함수 내에서 변경되지 않음을 보장합니다. 이는 특히 객체를 참조로 전달할 때 유용하며, 매개변수가 수정되지 않도록 하는 의도를 명확히 합니다.



특히, 상수 포인터를 정의할 때 const 쓰도록 리뷰할 수 있고, 포인터와 포인터가 가리키는 대상 둘 다 const로 선언하는 것을 유의해야 합니다.  

```cpp
const char* const name = "Pando Kim"; //const std::string name = "Pando Kim";
```



###### 02. STL 반복자(iterator)
STL 반복자는 포인터를 본뜬 것이어서 기본적으로 T* 와 비슷하게 동작한다. (T* const: 상수 포인터, 비상수 데이터)  
반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않는다. (포인터 변경 X)  
대신 반복자가 가리키는 대상 자체를 변경할 수는 있다.  

`issue`{:.error} 변경 불가능한 객체를 가리키는 반복자가 필요하다면?  
`Solution`{:.success} const_iterator 를 사용한다. (const T*: 비상수 포인터, 상수 데이터)  

```cpp
std::vector<int> vec;
const std::vector<int>::iterator iter = vec.begin();
*iter = 10; 
++iter; //error

const std::vector<int>::const_iterator cIter = vec.begin();
*cIter = 10; //error
++cIter;
```

###### 03. 함수 선언
함수를 const로 선언하면 좋은 점은 사용자 정의 타입을 사용할 때 실수하지 않을 수 있다는 점이다.  
사용자 정의 타입을 사용하면, 기본 타입과 쓸데없이 비호환성을 하지 않도록 해주는 특징이 있다.  
```cpp
Widget a, b, c;
//쓸데없이 비호환성을 하지 않도록 해주는 특징때문에 허용되는 것이 문제다.
if (a * b = c){ //비교하려고 했었는데, 대입해버렸다.  
    ...
}
```

## 클래스에서의 const
상수 멤버 함수는 해당 멤버 함수가 상수 객체에 대해 호출될 함수입니다. 즉, 객체의 상태를 변경하지 않음을 보장합니다.  
```cpp
class MyClass {
public:
  void myMethod() const {
    // 이 메서드는 객체의 상태를 변경하지 않음
  }
};
```
const 멤버 함수가 객체의 상태를 변경하지 않는지 검토하고, 필요 시 const를 사용할 수 있도록 리뷰할 수 있습니다.  


## 마치며
결론적으로 const를 사용할 위치와 목적에 맞게 사용할 수 있도록 리뷰해야 합니다. 변수, 객체, 배열, 함수 매개변수 등 각각의 컨텍스트에서 const가 어떻게 적용되는지 이해하고, 코드를 안정적으로 만드는 방법을 고민해보아야 합니다. 위에서 언급한 여러 가지 관점에서 const의 사용을 리뷰하면, 코드의 안정성과 가독성을 높이는 데 도움이 될 것입니다.