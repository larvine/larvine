---
title: "[E-Z] const 리뷰하기🍨"
key: codereview
# category: tdd
tags: codereview
---
codereview
<!--more-->

# [E-Z] const 리뷰하기🍨
저는 종종 단순한 상수를 써야할 때 const, enum, inline 등 여러 구현 방법이 있는데도 매크로를 곧바로 편하게 쓸 때가 많습니다. 하지만 이 때의 매크로의 단점은 뚜렷하긴 하죠. 가장 먼저 생각나는 것은 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하면 헷갈린다는 점입니다.🙄  

## 디버깅이 쉬운 const
```cpp
#define PI 3.14
const double pi=3.14;
```

소스코드가 컴파일러에게 PI를 알려주기 전에, 선행 처리자가 숫자 상수로 대체해버리므로 컴파일러는 PI가 아니라 3.14로 인식합니다. 즉, PI는 컴파일러의 기호 테이블에 들어가지 않습니다. 이렇게 되면 매크로 사용 중 오류가 발생하면, 컴파일러의 에러 메시지가 매크로 치환에 대한 정보를 제공하지 않기 때문에 에러의 원인을 추적하기 어렵습니다.  
그래서 단순한 상수를 쓸 때는, `매크로` 대신 `const 객체`(또는 enum)를 쓰는 편이 좋습니다. `const 변수`는 실제 메모리 위치에 저장되기 때문에, 디버깅 도구를 사용하여 변수의 값을 직접 확인할 수 있습니다. 이는 에러를 추적하는데 유리합니다.   

단순한 상수를 정의하는데 매크로를 썼다면, 그 대신에 디버깅에 용이한 const 변수를 써보자는 코드리뷰를 할 수 있겠습니다.  

## 타입 에러를 체크할 수 있는 const

```c
const int MAX_SIZE = 100;
int array[MAX_SIZE];
```

const는 타입을 갖기 때문에, 변수의 타입과 값의 일관성을 보장합니다. 컴파일러는 타입과 관련된 오류를 체크할 수 있습니다.


```c
#define MAX_SIZE 100
int array[MAX_SIZE];
```

매크로 상수는 타입이 없기 때문에, 매크로 상수와 다른 타입의 값이 연산에 사용될 때 타입 관련 오류가 발생하지 않습니다.  


## 스코프 내에서 유효한 const
```c
const int MAX_SIZE = 100;

void function() {
    int array[MAX_SIZE];
    // `const` 변수 MAX_SIZE는 타입이 명확하고, 스코프가 제한됨
}
```


const 변수는 스코프 내에서만 유효하므로, 전역적으로 사용되는 매크로에 비해 이름 충돌의 가능성이 적습니다. 이 때, 상수가 필요한 스코프 내에서만 선언되었는지 검토해볼 수 있습니다.       

```c
#define MAX_SIZE 100

void function() {
    int array[MAX_SIZE];
    // 매크로 상수 MAX_SIZE가 변경되면, 모든 사용 코드에 영향을 미침
}
```

반대로 매크로는 전역적으로 유효하기 때문에, 이름 충돌이나 예상치 못한 동작을 초래할 수 있습니다. 전역적으로 유효하다는 특성을 이용해서 효율적으로 코드를 구성할 때도 있지만, 이름 충돌에 대한 리스크는 있습니다. 반드시 필요한 경우가 아니라면, 불필요한 전역선언을 피하고 const 변수를 쓸 수 있도록 리뷰할 수 있습니다.  


## 코드 가독성을 높이는 const
const는 개발자의 의도가 분명하게 녹아 있습니다. const 키워드가 붙은 객체는 외부 변경이 안되고, 이를 `의미적인 제약`이라고 합니다. 이러한 의미적인 제약을 소스 코드 수준에서 붙이고, 컴파일러가 제약을 지켜줍니다. 한 마디로, 어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러와 다른 프로그래머와 나눌 수 있는 수단입니다.  
`코드 가독성`측면에서 소개했지만, 이 의미적인 제약에는 `의도치 않은 버그 방지`, `높은 유지보수성`, `주석 없이 불변성 명시` 등을 전부 내포하고 있습니다.  

## 상황별 const의 불변성 유의하기
### 상수 변수
첫째, 변수의 불변성을 확인하면서 const 변수를 리뷰할 수 있습니다.
```c
const x = 10;
x = 20; // 오류 발생
```

둘째, 상수로 선언된 변수들이 실제로 변경되지 않아야 하는 값들인지 검토합니다. 즉, 변수의 불변성이 논리적으로 맞는지 확인합니다.
```c
const MAX_USERS = 100; // 상수로 적절
const userName = 'John'; // 상수로 적절
```

계속해서 const의 장점 위주로 설명했지만, 값의 변경이 불가능하므로, 경우에 따라 유연성이 떨어질 수 있다는 단점이 될 수 있습니다. 값이 변경될 가능성이 있는 경우에는 const를 사용하기 적절하지 않을 수 있으므로 프로젝트의 
여러 상황을 고려하여 변수 불변성에 대한 논리성을 리뷰해볼 수 있습니다.

### 객체나 배열
객체나 배열을 const로 선언한 경우, 해당 객체나 배열의 요소는 변경할 수 있지만 변수 자체를 재할당할 수 없습니다. 이 점을 이해하고 적절히 사용되고 있는지 리뷰합니다.
```c
const arr = [1, 2, 3];
arr[2] = 4; // 가능
arr = [1, 2, 3, 4]; // 오류 발생
```

### 상수 포인터
특히, 상수 포인터를 정의할 때 const 쓰도록 리뷰할 수 있고, 포인터와 포인터가 가리키는 대상 둘 다 const로 선언하는 것을 유의해야 합니다.  

```cpp
const char* const name = "Pando Kim"; //const std::string name = "Pando Kim";
```

### 함수 매개변수
함수 매개변수에 const를 붙일 수 있는데, 이를 통해 매개변수가 함수 내에서 변경되지 않음을 보장할 수 있습니다.

```c
void printMessage(const std::string& message) {
    std::cout << message << std::endl;
    // message는 const 참조로 전달되어서 함수 내에서 변경할 수 없음
}
```
여기서 const std::string&는 message가 함수 내에서 변경되지 않음을 보장합니다. 이는 특히 객체를 참조로 전달할 때 유용하며, 매개변수가 수정되지 않도록 하는 의도를 명확히 합니다.

### 함수 반환 타입
함수 반환 타입에 const를 붙일 수 있는데, c와 cpp 에서의 활용 분야가 살짝 다르다는 점을 이해해야 합니다.
C에서는 함수 반환 타입에 const를 붙이는 것이 제한적이고, 주로 포인터와 함께 사용됩니다. 함수가 포인터를 반환하며, 반환된 포인터를 통해 접근할 수 있는 데이터의 변경을 방지합니다.

```c
const char* getGreeting() {
    return "Hello, world!";
}

int main() {
    const char* greeting = getGreeting();
    // greeting[0] = 'h'; // 오류: 반환된 문자열은 const로 선언되어 수정할 수 없음
}
```

물론 기본 데이터 타입에서도 반환 값이 변경되지 않도록 보장할 수 있습니다. 그러나, 값 타입에는 주로 const를 붙이는 것이 거의 필요 없습니다.

```c
const int getValue() {
    return 42;
}

int main() {
    const int value = getValue();
    // value = 50; // 오류: value는 const로 선언되어서 변경 불가
}
```

cpp에서는 함수 반환 타입에 const를 더 널리 사용하며, 포인터, 참조, 객체 등 다양한 경우에 적용됩니다. 포인터 반환의 경우, c와 같습니다.  
`const 객체 참조 반환`은 객체를 참조로 반환하되, 객체의 변경을 방지합니다. 특히 클래스의 멤버 함수에서 유용합니다.

```cpp
class MyClass {
public:
    const std::string& getName() const {
        return name;
    }
private:
    std::string name = "Example";
};

int main() {
    MyClass obj;
    const std::string& name = obj.getName();
    // name += " Changed"; // 오류: name은 const로 선언되어서 수정 불가
}
```

여기서 const std::string&는 getName 함수가 반환하는 참조가 const로 되어 있어, 반환된 참조를 통해 객체의 상태를 변경할 수 없습니다.
`const 객체 반환`은 객체를 반환하되, 반환된 객체는 변경할 수 없음을 보장합니다.

```cpp
const std::string getString() {
    return "Hello, world!";
}

int main() {
    const std::string str = getString();
    // str += " Changed"; // 오류: str은 const로 선언되어서 수정 불가
}
```
여기서 const std::string는 반환된 std::string 객체가 변경되지 않도록 보장합니다.

이러한 const를 적절히 사용하면, 함수의 반환 값이 의도한 대로 변경되지 않도록 하여 코드의 안정성과 신뢰성을 높일 수 있습니다.

### 상수 멤버 함수
상수 멤버 함수는 해당 멤버 함수가 상수 객체에 대해 호출될 함수입니다. 즉, 객체의 상태를 변경하지 않음을 보장합니다.  
```cpp
class MyClass {
public:
  void myMethod() const {
    // 이 메서드는 객체의 상태를 변경하지 않음
  }
};
```
const 멤버 함수가 객체의 상태를 변경하지 않는지 검토하고, 필요할 때 const를 사용할 수 있도록 리뷰할 수 있습니다.  


## 마치며
결론적으로 const를 사용할 위치와 목적에 맞게 사용할 수 있도록 리뷰해야 합니다.😉 변수, 객체, 배열, 함수 매개변수 등 각각의 컨텍스트에서 const가 어떻게 적용되는지 이해하고, 코드를 안정적으로 만드는 방법을 고민해보아야 합니다. 위에서 언급한 여러 가지 관점에서 const의 사용을 리뷰하면, 코드의 안정성과 가독성을 높이는데 도움이 될 것입니다.