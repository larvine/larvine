---
title: "[E-Z] const 리뷰하기🍨"
key: codereview
# category: tdd
tags: codereview
---
codereview
<!--more-->

# [E-Z] const 리뷰하기🍨
저는 종종 단순한 상수를 써야할 때 const, enum, inline 등 여러 구현 방법이 있는데도 매크로를 곧바로 편하게 쓸 때가 많습니다. 하지만 이 때의 매크로의 단점은 뚜렷하긴 하죠. 가장 먼저 생각나는 것은 숫자 상수로 대체된 코드에서 컴파일 에러라도 발생하면 헷갈린다는 점입니다.🙄  

## 디버깅이 쉬운 const
```cpp
#define PI 3.14
const double pi=3.14;
```

소스코드가 컴파일러에게 PI를 알려주기 전에, 선행 처리자가 숫자 상수로 대체해버리므로 컴파일러는 PI가 아니라 3.14로 인식합니다. 즉, PI는 컴파일러의 기호 테이블에 들어가지 않습니다. 이렇게 되면 매크로 사용 중 오류가 발생하면, 컴파일러의 에러 메시지가 매크로 치환에 대한 정보를 제공하지 않기 때문에 에러의 원인을 추적하기 어렵습니다.  
그래서 단순한 상수를 쓸 때는, `매크로` 대신 `const 객체`(또는 enum)를 쓰는 편이 좋습니다. `const 변수`는 실제 메모리 위치에 저장되기 때문에, 디버깅 도구를 사용하여 변수의 값을 직접 확인할 수 있습니다. 이는 에러를 추적하는데 유리합니다.   

단순한 상수를 정의하는데 매크로를 썼다면, 그 대신에 디버깅에 용이한 const 변수를 써보자는 코드리뷰를 할 수 있겠습니다.  

## 타입 에러를 체크할 수 있는 const

```c
const int MAX_SIZE = 100;
int array[MAX_SIZE];
```

const는 타입을 갖기 때문에, 변수의 타입과 값의 일관성을 보장합니다. 컴파일러는 타입과 관련된 오류를 체크할 수 있습니다.


```c
#define MAX_SIZE 100
int array[MAX_SIZE];
```

매크로 상수는 타입이 없기 때문에, 매크로 상수와 다른 타입의 값이 연산에 사용될 때 타입 관련 오류가 발생하지 않습니다.  


## 스코프 내에서 유효한 const
```c
const int MAX_SIZE = 100;

void function() {
    int array[MAX_SIZE];
    // `const` 변수 MAX_SIZE는 타입이 명확하고, 스코프가 제한됨
}
```


const 변수는 스코프 내에서만 유효하므로, 전역적으로 사용되는 매크로에 비해 이름 충돌의 가능성이 적습니다. 이 때, 상수가 필요한 스코프 내에서만 선언되었는지 검토해볼 수 있습니다.       

```c
#define MAX_SIZE 100

void function() {
    int array[MAX_SIZE];
    // 매크로 상수 MAX_SIZE가 변경되면, 모든 사용 코드에 영향을 미침
}
```

반대로 매크로는 전역적으로 유효하기 때문에, 이름 충돌이나 예상치 못한 동작을 초래할 수 있습니다. 전역적으로 유효하다는 특성을 이용해서 효율적으로 코드를 구성할 때도 있지만, 이름 충돌에 대한 리스크는 있습니다. 반드시 필요한 경우가 아니라면, 불필요한 전역선언을 피하고 const 변수를 쓸 수 있도록 리뷰할 수 있습니다.  


## 코드 가독성을 높이는 const
const는 개발자의 의도가 분명하게 녹아 있습니다. const 키워드가 붙은 객체는 외부 변경이 안되고, 이를 `의미적인 제약`이라고 합니다. 이러한 의미적인 제약을 소스 코드 수준에서 붙이고, 컴파일러가 제약을 지켜줍니다. 한 마디로, 어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러와 다른 프로그래머와 나눌 수 있는 수단입니다. `코드 가독성`측면에서 소개했지만, 이 의미적인 제약에는 `의도치 않은 버그 방지`, `높은 유지보수성`, `주석 없이 불변성 명시` 등을 전부 내포하고 있습니다.  

이러한 점을 유의한다면 첫째, 변수의 불변성을 확인하면서 const 변수를 리뷰할 수 있습니다.
```c
const x = 10;
x = 20; // 오류 발생
```

둘째, 상수로 선언된 변수들이 실제로 변경되지 않아야 하는 값들인지 검토합니다. 즉, 변수의 불변성이 논리적으로 맞는지 확인합니다.
```c
const MAX_USERS = 100; // 상수로 적절
const userName = 'John'; // 상수로 적절
```

객체나 배열을 const로 선언한 경우, 해당 객체나 배열의 요소는 변경할 수 있지만 변수 자체를 재할당할 수 없습니다. 이 점을 이해하고 적절히 사용되고 있는지 리뷰합니다.
```c
const arr = [1, 2, 3];
arr[2] = 4; // 가능
arr = [1, 2, 3, 4]; // 오류 발생
```



상수 포인터를 정의할 때 const 쓰자  
포인터와 포인터가 가리키는 대상 둘 다 const로 선언한다.  
```cpp
const char* const name = "Larvine Kim"; //const std::string name = "Larvine Kim";
```

`caution`{:.warning} 클래스 상수를 정의할 때 상수의 사본 개수를 1개로 정하고 싶다면 static member로 만들자  
```cpp
class GamePlayer{
    private:
        static const int numTurns = 5; //선언
        int scores[numTurns];
}
```

`caution`{:.warning} static member로 만들어지는 정수류 타입(각종 정수타입, char, bool 등)의 클래스 내부 상수는 선언만 해도 된다!  
단, 클래스 상수의 주소를 구하는 경우, 컴파일러가 정의를 해라고 하는 경우에는 별도로 정의해야 한다.  

```cpp 
const int GamePlayer::numTurns; //정의
```
클래스 상수는 선언할 때 초기화하므로 정의할 때는 값을 주지 않는다. 이 때, 오래된 컴파일러 중 반대로 static 클래스 멤버가 선언할 때 초기값을 줘서는 안된다고 하는 경우도 있으니, 
이 때는 반대로 한다. 이에 대한 해결책으로 `나열자 둔갑술(enum hack)`이 있다.      

`caution`{:.warning} #define는 클래스 상수를 정의하는데 쓸 수 없고, private 등 캡슐화도 안된다.  


const는 어떤 유효 범위에 있는 객체에도 붙을 수 있고, 함수 매개변수, 반환타입, 멤버함수 등에 붙을 수 있다.  
{:.info}
- 오른편을 꾸며준다고 여기자.

###### 01. 포인터

```cpp
char str[] = "string";
char *p = a; //비상수 포인터, 비상수 데이터
const char *p = a; //비상수 포인터, 상수 데이터
char* const p = a; //상수 포인터, 비상수 데이터
const char* const p = a; //상수 포인터, 상수 데이터
void f1(const Widget *pw); //상수 Widget 객체에 대한 포인터
void f2(Widget const *pw); //상수 Widget 객체에 대한 포인터 == const Widget *
```

###### 02. STL 반복자(iterator)
STL 반복자는 포인터를 본뜬 것이어서 기본적으로 T* 와 비슷하게 동작한다. (T* const: 상수 포인터, 비상수 데이터)  
반복자는 자신이 가리키는 대상이 아닌 것을 가리키는 경우가 허용되지 않는다. (포인터 변경 X)  
대신 반복자가 가리키는 대상 자체를 변경할 수는 있다.  

`issue`{:.error} 변경 불가능한 객체를 가리키는 반복자가 필요하다면?  
`Solution`{:.success} const_iterator 를 사용한다. (const T*: 비상수 포인터, 상수 데이터)  

```cpp
std::vector<int> vec;
const std::vector<int>::iterator iter = vec.begin();
*iter = 10; 
++iter; //error

const std::vector<int>::const_iterator cIter = vec.begin();
*cIter = 10; //error
++cIter;
```

###### 03. 함수 선언
함수를 const로 선언하면 좋은 점은 사용자 정의 타입을 사용할 때 실수하지 않을 수 있다는 점이다.  
사용자 정의 타입을 사용하면, 기본 타입과 쓸데없이 비호환성을 하지 않도록 해주는 특징이 있다.  
```cpp
Widget a, b, c;
//쓸데없이 비호환성을 하지 않도록 해주는 특징때문에 허용되는 것이 문제다.
if (a * b = c){ //비교하려고 했었는데, 대입해버렸다.  
    ...
}
```

###### 04. 매개변수

###### 05. 상수 멤버 함수: 해당 멤버 함수가 상수 객체에 대해 호출될 함수이다. (ex: auto func() const -> void)
* 클래스의 인터페이스를 이해하기 쉽다.  
  * 클래스로 만들어진 객체를 변경할 수 있는 함수와 변경할 수 없는 함수를 사용자가 미리 알 수 있다.  
* 상수 객체를 사용할 수 있게 한다.
  * 상수 객체에 대한 참조자로 객체를 전달하면 성능에 유리하다. 
  * 상수 매개변수를 조작할 수 있는 const 멤버 함수가 필요하다. 


논리적인 상수성을 사용해서 프로그래밍한다.  
상수 멤버와 비상수 멤버 함수가 기능적으로 서로 똑같이 구현되어 있다면, 코드 중복을 피하는 것이 좋다. 
이 때, 비상수 버전이 상수 버전을 호출하도록 하자.  


`const`와 매크로는 각각 장단점이 있으며, `const`는 타입 안전성과 디버깅 용이성, 스코프 관리 면에서 매크로보다 우수한 경우가 많습니다. 매크로는 간단한 상수 값을 정의할 때 유용하지만, 타입 검사가 없고 디버깅이 어려운 점이 있습니다. 따라서 현대 C 코드에서는 가능한 한 `const`를 사용하는 것이 좋습니다. `const`는 코드의 의도를 명확히 하고, 컴파일 타임에 타입 체크를 통해 오류를 사전에 방지하는 데 도움이 됩니다.